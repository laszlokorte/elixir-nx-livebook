<!-- livebook:{"file_entries":[{"name":"perlgirl.png","type":"attachment"}]} -->

# Introduction to Elixir Nx

```elixir
Mix.install([
  {:nx, "~> 0.10.0"},
  {:kino, "~> 0.18.0"},
  {:image, "~> 0.62.1"},
  {:kino_zoetrope, "~> 0.11.0"}
])

Kino.nothing()
```

## Nx.Tensor

```elixir
Nx.tensor([1,2,3,4,5,6])
|> Nx.reshape({3,2})
|> Nx.reduce_max()
|> Nx.to_number()
# |> dbg
```

```elixir
Nx.tensor([1,2,3,4,5,6])
|> Nx.reshape({3,2})
|> Nx.new_axis(-1)
|> Nx.shape()
```

```elixir
Nx.tensor([1,2,3,4,5,6], type: :f32)
|> Nx.new_axis(-1)
|> Nx.size()
```

```elixir
Nx.tensor([1,2,3,4,5,6])
|> Nx.reshape({3,:auto})
|> Nx.new_axis(0)
|> Nx.new_axis(2)
|> Nx.new_axis(0)
# |> dbg
|> Nx.shape

```

```elixir
Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12])
|> Nx.reshape({4,:auto,1})
|> KinoZoetrope.TensorStack.new()

```

```elixir
[
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({4,3,1}),
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({3,4,1}),
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({6,2,1}),
  
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) 
    |> Nx.reshape({4,3,1}) 
    |> Nx.transpose(axes: [1,0,2]),
]
|> KinoZoetrope.TensorStack.new(
  title: "Some reshaped and transposed Tensors",
  labels: ["3x4", "4x3", "2x6 with colormap", "transposed with colormap"],
  cmaps: [
    nil,nil,"rainbow","viridis",
  ]
)
```

```elixir
Nx.broadcast(255, {64,64,1})
|> KinoZoetrope.TensorStack.new(
  titel: "64x64 from single value",
  vmin: 0,
  vmax: 255
)
```

```elixir
Nx.broadcast(128, {64, 64, 3})
|> Nx.reshape({1, 64,64, 3})
|> KinoZoetrope.TensorStack.new(
  titel: "RGB image with all channels = 128 (gray)"
)
```

```elixir
Nx.stack([
  Nx.broadcast(0, {64, 64}),
  Nx.broadcast(100, {64, 64}),
  Nx.broadcast(0, {64, 64}),
  Nx.broadcast(100, {64, 64}),
  Nx.broadcast(0, {64, 64}),
  Nx.broadcast(100, {64, 64}),
])
|> KinoZoetrope.TensorStack.new(
  titel: "Multiple images stacked to an animatio"
)
```

```elixir
Nx.stack([
  Nx.concatenate([
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2),
  Nx.concatenate([
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2),
  Nx.concatenate([
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2)
])
|> KinoZoetrope.TensorStack.new(
  titel: "Multiple RGBA images stacked"
)
```

```elixir
[
  Nx.broadcast(255, {64,64,1}) |> Nx.add(Nx.iota({1,64,1})), 
  Nx.broadcast(255, {64,64,1}) |> Nx.add(Nx.iota({64,1,1}))
]
|> KinoZoetrope.TensorStack.new(
  labels: ["Horizontal Gradient", "Vertical Gradient"]
)
```

```elixir
colormix = Nx.concatenate([
  # red
  Nx.broadcast(0, {64,64}) 
    |> Nx.add(Nx.multiply(4, Nx.iota({64}))) 
    |> Nx.reshape({64,64,1}),

  #green
  Nx.broadcast(0, {64,64}) 
    |> Nx.add(Nx.multiply(4, Nx.iota({64,1}))) 
    |> Nx.reshape({64,64,1}),

  #blue
  Nx.broadcast(152, {64,64,1}),

  # alpha
  Nx.broadcast(255, {64,64,1})
], axis: 2)
|> Nx.reshape({1, 64,64, 4})

colormix
|> KinoZoetrope.TensorStack.new(
  titel: "Colorful gradient mixed from 3 channels"
)
```

```elixir
defmodule UsingOperators do 
  import Nx.Defn

  # Operatoren können in defn benutzt werden
  defn some_calculation(tensor) do
    600 - Nx.abs(tensor - 7*7 / 2) ** 1.5
  end
end

UsingOperators.some_calculation(Nx.iota({7,7, 1}))
|> KinoZoetrope.TensorStack.new()
```

```elixir
rad = 32
diam = 2*rad

dx2 = Nx.iota({1,diam,1})
  |> Nx.broadcast({diam,diam,1})
  |> Nx.subtract(rad)
  |> Nx.pow(2)

dy2 = Nx.iota({diam,1,1})
  |> Nx.broadcast({diam,diam,1})
  |> Nx.subtract(rad)
  |> Nx.pow(2)

circle = Nx.add(dx2, dy2) |> Nx.sqrt() 
  |> Nx.reshape({1, diam,diam, 1})

[dx2, dy2, circle]
|> KinoZoetrope.TensorStack.new(
  titel: "Circular masked generated via thresholding",
  labels: ["Distance y²", "Distance y²", "Radius"]
)
```

```elixir
mask = circle
  |> Nx.less_equal(23)
  |> Nx.reshape({1, 64,64, 1})

[
  circle,
  mask,
  mask |> Nx.logical_not(),
  circle |> Nx.multiply(0.5) |> Nx.sin,
  circle |> Nx.pow(0.3) |> Nx.multiply(10) |> Nx.sin(),
  
  5..40//2 
  |> Enum.map(&Nx.sin(Nx.multiply(Nx.pow(circle, 2/&1), 2*&1))) 
  |> Nx.concatenate(axis: 0)
]
|> KinoZoetrope.TensorStack.new(
  titel: "Circular masked generated via thresholding",
  labels: ["Circle", "Inner", "Outer","Rings","Squashed Rings", "Animated Rings"],
  cmaps: [nil,nil,nil,nil,"viridis","rainbow"]
)
```

```elixir
Enum.zip(
  1..140 |> Enum.map(&:math.sin(&1/3)*20), 
  20..140 |> Enum.map(&:math.sin(&1/7)*17)
)
|> Enum.map(
  fn {x,y} -> 
    Nx.add(
      Nx.iota({1,diam,1})
        |> Nx.broadcast({diam,diam,1})
        |> Nx.subtract(rad + x)
        |> Nx.pow(2), 
        
      Nx.iota({diam,1,1})
        |> Nx.broadcast({diam,diam,1})
        |> Nx.subtract(rad + y)
        |> Nx.pow(2)
    )
    |> Nx.sqrt()
    |> Nx.reshape({1, diam,diam, 1})
  end
)
|> Nx.concatenate(axis: 0)
|> Nx.less_equal(10)
|> KinoZoetrope.TensorStack.new(
  titel: "Animated Mask",
  cmap: "viridis"
)
```

```elixir
1..3
|> Enum.map(fn c ->
  Enum.zip(
    1..90 |> Enum.map(&:math.sin(&1/17.0+c)*20), 
    1..90 |> Enum.map(&:math.cos(c*&1/13.0+c)*17)
  )
  |> Enum.map(&Nx.add(
      Nx.iota({1,diam,1})
      |> Nx.broadcast({diam,diam,1})
      |> Nx.subtract(rad+ elem(&1, 0))
      |> Nx.pow(2), 
      Nx.iota({diam, 1,1})
      |> Nx.broadcast({diam,diam,1})
      |> Nx.subtract(rad+elem(&1, 1))
      |> Nx.pow(2)
  )
  |> Nx.reshape({1, diam,diam, 1})
  )
  |> Nx.concatenate(axis: 0)  
  |> Nx.sqrt()
end)
|> Nx.concatenate(axis: 3) 
|> then(&Nx.subtract(1, &1))
|> then(&Nx.subtract(&1, Nx.reduce_min(&1)))
|> then(&Nx.divide(&1, Nx.reduce_max(&1)))
|> Nx.multiply(255)
|> KinoZoetrope.TensorStack.new(
  titel: "Animated Color channels"
)
```

```elixir
Nx.multiply(mask, colormix)
|> KinoZoetrope.TensorStack.new(
  titel: "Gradient cut with circular mask"
)
```

```elixir
size = 64

gauss = Nx.add(
  Nx.broadcast(0, {size,size,1})
    |> Nx.add(Nx.iota({1,size,1}))
    |> Nx.reshape({1, size,size})
    |> Nx.subtract(size / 2 - 0.5)
    |> Nx.pow(2), 
  Nx.broadcast(0, {size,size,1})
    |> Nx.add(Nx.iota({size,1,1}))
    |> Nx.reshape({1, size,size})
    |> Nx.subtract(size/2 - 0.5)
    |> Nx.pow(2)
)
|> Nx.divide(Nx.pow(size/4, 2))
|> Nx.negate()
|> Nx.exp()

gauss
|> KinoZoetrope.TensorStack.new(
  titel: "Gaußian Mask / Filter of size #{size}x#{size}"
)
```

```elixir
[
  Nx.stack([
    gauss,
    gauss,
    gauss,
    Nx.broadcast(1.0, {1, 64, 64})
  ],axis: 3) 
  |> Nx.pow(0.4)
  |> Nx.multiply(colormix)
  |> Nx.multiply(1.5)
  |> Nx.min(255),

  Nx.stack([
    Nx.broadcast(1.0, {1, 64, 64}),
    Nx.broadcast(1.0, {1, 64, 64}),
    gauss,
    Nx.broadcast(1.0, {1, 64, 64})
  ],axis: 3) 
  |> Nx.multiply(colormix)
  |> Nx.min(255),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Color gradient multiplied with gaussien mask",
  labels: ["All channels multiplied", "Only blue channel masked out"]
)
```

```elixir
{:ok, img} = Image.open(Kino.FS.file_path("perlgirl.png"))
{:ok, bin} = Vix.Vips.Image.write_to_binary(img)

girl_col = bin 
  |> Nx.from_binary(:u8) 
  |> Nx.reshape({1, 64, 64, 4}) 

girl_bw = bin |> Nx.from_binary(:u8) 
|> Nx.reshape({64, 64, 4}) 
# Discard alpha Channel
|> Nx.slice_along_axis(0, 3, axis: 2)
# average color channels
|> Nx.mean(axes: [2])
|> Nx.as_type(:u8)
|> Nx.reshape({64, 64, 1})

[
  girl_col, 
  girl_col |> Nx.transpose(axes: [3,1,2,0]), 
  girl_bw
] 
|> KinoZoetrope.TensorStack.new(
  titel: "Image read from the file system",
  labels: ["RGBA Image", "Single Channel (Slider)", "Grayscale (mean)"]
)
```

```elixir
make_gauss = fn size -> 
  Nx.add( Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({1,size,1})) 
    |> Nx.reshape({1, size,size, 1}) 
    |> Nx.subtract(size / 2 - 0.5) 
    |> Nx.pow(2), Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({size,1,1})) 
    |> Nx.reshape({1, size,size, 1})
    |> Nx.subtract(size/2 - 0.5) 
    |> Nx.pow(2) ) 
    |> Nx.divide(Nx.pow(size/4, 2)) 
    |> Nx.as_type(:f32)
    |> Nx.negate() 
    |> Nx.exp() 
    |> then(&Nx.divide(&1, Nx.sum(&1)))
    |> Nx.reshape({1,1,size,size})
    |> Nx.broadcast({4, 1,size,size})
end

11
|> then(&[
  # Original RGBA
  girl_col,

  # Blurred Result
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(&1), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [0,2,3,1]),

  # single channel
  girl_col |> Nx.transpose(axes: [3,1,2,0]),

  # Filter
  make_gauss.(&1) |> Nx.transpose(axes: [0,2,3,1]),

  # Single channel result
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(&1), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])
])
|> KinoZoetrope.TensorStack.new(
  titel: "Blurred Color Image",
  labels: [
    "Original RGBA", 
    "Result RGBA", 
    "Single Channel (slider)", 
    "Gaußian Filter", 
    "Result Single Channel (slider)"
  ]
)
```

```elixir
make_sobel = fn orientation -> 
  Nx.tensor([
    [-1,-2,-1],
    [ 0, 0, 0],
    [+1,+2,+1]
  ])
  |> Nx.transpose(axes: case orientation do 
      :vertical -> [1,0]
      :horizontal -> [0,1]
    end)
  |> Nx.reshape({1,1,3,3})
  |> then(&Nx.concatenate([&1,&1,&1,Nx.broadcast(1/9.0, {1,1,3,3})], axis: 0))
end


for orient <- [:vertical, :horizontal] do 
[
  girl_col |> Nx.transpose(axes: [3,1,2,0]),
  
  make_sobel.(orient) |> Nx.transpose(axes: [0,2,3,1]),

  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(orient), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])
]
end
|> List.flatten()
|> KinoZoetrope.TensorStack.new(
  titel: "Edge Detection via Sobel Filter",
  labels: [
    "Single Channel (slider)", "horizontal filter", "horizontal result", 
    "Single Channel (slider)", "vertical filter", "vertical result", 
  ],
  cmap: "viridis"
)
```

```elixir
make_gauss = fn size -> 
  Nx.add( 
    Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({1,size,1})) 
    |> Nx.reshape({1, size,size, 1}) 
    |> Nx.subtract(size / 2 - 0.5) 
    |> Nx.pow(2), Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({size,1,1})) 
    |> Nx.reshape({1, size,size, 1})
    |> Nx.subtract(size/2 - 0.5) 
    |> Nx.pow(2)
  ) 
  |> Nx.divide(Nx.pow(size/4, 2)) 
  |> Nx.as_type(:f32)
  |> Nx.negate() 
  |> Nx.exp() 
  |> then(&Nx.divide(&1, Nx.sum(&1)))
  |> Nx.reshape({1,1,size,size})
  |> Nx.broadcast({4, 1,size,size})
end

make_sobel = fn orientation -> 
  Nx.tensor([
    [-1,-2,-1],
    [ 0, 0, 0],
    [+1,+2,+1]
  ])
  |> Nx.transpose(axes: case orientation do 
      :vertical -> [1,0]
      :horizontal -> [0,1]
    end)
  |> Nx.reshape({1,1,3,3})
  |> then(&Nx.concatenate([&1,&1,&1,Nx.broadcast(1/9.0, {1,1,3,3})], axis: 0))
end

hypot = fn a, b ->
  Nx.sqrt(Nx.add(Nx.pow(a,2), Nx.pow(b,2)))
end

soft_girl_col = 
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(3), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [0,2,3,1])


verts = soft_girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(:vertical), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])

horts = soft_girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(:horizontal), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])

orient = Nx.atan2(verts, horts)

[
  soft_girl_col |> Nx.transpose(axes: [3,1,2,0]),
  verts,
  horts,
  orient,
  orient,
  hypot.(verts, horts) 
  |> Nx.greater_equal(0.5)
  |> Nx.multiply(orient)
]
|> KinoZoetrope.TensorStack.new(
  titel: "Edge Orientation",
  labels: [
    "Single Channel (slider)", "Vertical Result", "Horizontal Result", 
    "Edge Orientation", "Edge Orientation", "masked orientation", 
  ],
  cmaps: [nil, "viridis", "viridis", "gray", "hsv", "hsv"]
)
```

## Game of Life

```elixir
world = Nx.tensor([
  [0,0,1,0,0,0,0,0,0,0,0],
  [1,0,1,0,0,0,0,0,0,0,0],
  [0,1,1,0,0,0,0,1,0,0,0],
  [0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0],
  [0,0,1,0,0,0,0,0,0,0,0],
  [0,0,0,1,0,0,0,0,0,0,0],
  [0,1,1,1,0,0,0,1,0,1,0],
  [0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,1,0,0],
])
|> Nx.reshape({1,11,11,1})

gol_filter = Nx.tensor([
  [1.0,1.0,1.0],
  [1.0,0.5,1.0],
  [1.0,1.0,1.0]
])
|> Nx.reshape({1,3,3,1})
  
[
  Nx.subtract(1, world),
  gol_filter,
] |> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  vmin: 0,
  vmax: 1,
  labels: ["World (inverted)", "Filter Kernel"]
)
```

```elixir
world = Nx.tensor([
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,1,0,0,0,0,0,0,0,0],
  [0,0,1,1,0,0,0,0,1,0,0,0],
  [0,0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,1,0,0,0,0,0,0,0],
  [0,0,1,1,1,0,0,0,1,0,1,0],
  [0,0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],

])
|> Nx.reshape({1,12,12,1})
|> Nx.transpose(axes: [0,3,1,2])


gol_filter = Nx.tensor([
  [1.0,1.0,1.0],
  [1.0,0.3,1.0],
  [1.0,1.0,1.0],
])
|> Nx.reshape({1,1,3,3})

circular_pad_2d = fn tensor, pad_h, pad_w ->
  {_n, _c, h, w} = Nx.shape(tensor)
  h_idx =
    Nx.remainder(
      Nx.add(h, Nx.subtract(Nx.iota({h + 2 * pad_h}), pad_h)),
      h
    )
  w_idx =
    Nx.remainder(
      Nx.add(w, Nx.subtract(Nx.iota({w + 2 * pad_w}), pad_w)),
      w
    )
  
  tensor
  |> Nx.take(h_idx, axis: 2)
  |> Nx.take(w_idx, axis: 3)
end

do_step = fn state -> 
  circular_pad_2d.(state, 1,1)
  |> Nx.conv(gol_filter)
  |> Nx.subtract(3)
  |> Nx.abs()
  |> Nx.less(1)
end

[
  Stream.iterate(world, do_step)
    |> Enum.take(40)
    |> Enum.drop(1)
    |> Enum.map(&Nx.transpose(Nx.subtract(1, &1), axes: [0,2,3,1]))
    |> Nx.concatenate(),
  
  Stream.iterate(world, do_step)
    |> Enum.take(40)
    |> Enum.map(&Nx.transpose(Nx.subtract(1, &1), axes: [0,2,3,1]))
    |> Nx.concatenate(),
    
  gol_filter|> Nx.reshape({1,3,3,1})
]
|> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  labels: ["World (Prev)" , "World (next)", "Filter Kernel"],
  vmin: 0,
  vmax: 1
)
```

```elixir
world = Nx.tensor([[
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,1,0,0,0,0,0,0,0,0],
  [0,0,1,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
]])

gol_filter_spectrum = Nx.fft2(Nx.tensor([
  [0.5,1,0,0,0,0,0,0,0,0,0,1.0],
  [1.0,1,0,0,0,0,0,0,0,0,0,1.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [1.0,1.0,0,0,0,0,0,0,0,0,0,1.0],
]))


do_step = fn state -> 
  Nx.ifft2(Nx.multiply(Nx.fft2(state), gol_filter_spectrum))
  |> Nx.subtract(3)
  |> Nx.abs()
  |> Nx.less(1)
end

Stream.iterate(world, do_step)
|> Enum.take(100)
|> Enum.map(&Nx.reshape(Nx.subtract(1, &1), {1,12,12,1}))
|> Nx.concatenate()
|> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  labels: ["World (Inverted)"]
)
```
