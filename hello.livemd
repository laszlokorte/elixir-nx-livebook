<!-- livebook:{"file_entries":[{"name":"hex.png","type":"attachment"},{"name":"perlgirl.png","type":"attachment"}]} -->

# Introduction to Elixir Nx

```elixir
Mix.install([
  {:nx, "~> 0.10.0"},
  {:kino, "~> 0.18.0"},
  {:image, "~> 0.62.1"},
  {:kino_zoetrope, "~> 0.12.0"}
])

Kino.nothing()
```

## Nx.Tensor

The goal of this notebook is a playful introduction to image processing and tensor programming via Elixir Nx.

<!-- livebook:{"break_markdown":true} -->

A Tensor is a generalization of matrices into higher dimensions. As programmer you can think of a Tensor as an n-dimensional array.

```elixir
# Create a new tensor of 6 elements
Nx.tensor([1,2,3,4,5,6])
# change the tensor from being 1-dimensional into 2-dimensional
# with 3 rows across the first dimension and 2 columns along the second dimension
|> Nx.reshape({3, 2}) # still 6 = 3x2 elements
|> Nx.reduce_max() # find the largest value in the tensor
|> Nx.to_number() # extract a single number from a 0-dimensional tensor
# |> dbg
```

```elixir
Nx.tensor([1,2,3,4,5,6])
|> Nx.reshape({3, 2})
|> Nx.new_axis(-1) # new dimensions can be added
|> Nx.shape() # ask the tensor for its shape
```

```elixir
Nx.tensor([1,2,3,4,5,6], type: :f32)
|> Nx.new_axis(-1)
|> Nx.size() # the total number of elements in the tensor
```

```elixir
Nx.tensor([1,2,3,4,5,6])
|> Nx.reshape({3, :auto})
|> Nx.new_axis(0) # dimensions can be added
|> Nx.new_axis(2) # in different
|> Nx.new_axis(0) # places
# |> dbg
|> Nx.shape

```

```elixir
Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12])
|> Nx.reshape({4, :auto, 1})
# We can view 2d, 3d and 4d tensors as bitmap images
|> KinoZoetrope.TensorStack.new(
  titel: "A tensor plotted as 2D grayscale bitmap"
)
```

```elixir
[
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({4,3,1}),
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({3,4,1}),
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) |> Nx.reshape({6,2,1}),
  
  Nx.tensor([1,2,3,4,5,6,7,8,9,10,11,12]) 
    |> Nx.reshape({4,3,1}) 
    |> Nx.transpose(axes: [1,0,2]),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Some reshaped and transposed Tensors",
  labels: ["3x4", "4x3", "2x6 with colormap", "transposed with colormap"],
  cmaps: [
    nil, nil, "rainbow", "viridis",
  ]
)
```

```elixir
Nx.broadcast(255, {64,64,1})
|> KinoZoetrope.TensorStack.new(
  titel: "64x64 from single value",
  vmin: 0,
  vmax: 255
)
```

```elixir
Nx.broadcast(128, {64, 64, 3})
|> Nx.reshape({1, 64,64, 3})
|> KinoZoetrope.TensorStack.new(
  titel: "RGB image with all channels = 128 (gray)"
)
```

```elixir
Nx.broadcast(200, {64, 64, 4})
|> Nx.reshape({1, 64,64, 4})
|> KinoZoetrope.TensorStack.new(
  titel: "RGBA image with all channels = 200 (gray transparent)"
)
```

```elixir
Nx.stack([
  Nx.broadcast(0, {64, 64}),
  Nx.broadcast(100, {64, 64}),
  Nx.broadcast(20, {64, 64}),
  Nx.broadcast(50, {64, 64}),
  Nx.broadcast(30, {64, 64}),
  Nx.broadcast(20, {64, 64}),
])
|> KinoZoetrope.TensorStack.new(
  titel: "Multiple images stacked to an animation",
  labels: ["3D tensor"]
)
```

```elixir
Nx.stack([
  Nx.concatenate([
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2),
  Nx.concatenate([
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2),
  Nx.concatenate([
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(0, {64, 64,1}),
    Nx.broadcast(150, {64, 64,1}),
    Nx.broadcast(255, {64, 64,1}),
  ], axis: 2)
])
|> KinoZoetrope.TensorStack.new(
  titel: "Multiple RGBA images stacked"
)
```

```elixir
[
  Nx.iota({1,64,1}) |> Nx.divide(63) |> Nx.broadcast({64,64,1}), 
  Nx.iota({64,1,1}) |> Nx.divide(63) |> Nx.broadcast({64,64,1}) 
]
|> KinoZoetrope.TensorStack.new(
  titel: "Gradients",
  labels: ["Horizontal Gradient", "Vertical Gradient"]
)
```

```elixir
colormix = Nx.concatenate([
  # red
  Nx.iota({64, 1, 1})
    |> Nx.multiply(4)
    |> Nx.broadcast({64,64,1}),

  #green
  Nx.iota({1, 64, 1})
    |> Nx.multiply(4)
    |> Nx.broadcast({64,64,1}),

  #blue
  Nx.tensor(152) |>
  Nx.broadcast({64,64,1}),

  # alpha
  Nx.tensor(255) |>
  Nx.broadcast({64,64,1})
], axis: 2)
|> Nx.reshape({1, 64,64, 4})

[
  colormix | 
  0..2 |> Enum.map(&Nx.take(colormix, Nx.tensor([&1]), axis: 3))
]
|> KinoZoetrope.TensorStack.new(
  titel: "Colorful gradient mixed from 3 channels",
  labels: ["RGB", "Red", "Green", "Blue"],
  vmin: 0,
  vmax: 255
)
```

```elixir
colormix
|> Nx.multiply(Nx.concatenate([
  1 |> Nx.broadcast({1,64,64,1}), # R
  1 |> Nx.broadcast({1,64,64,1}), # G
  1 |> Nx.broadcast({1,64,64,1}), # B
  # Alpha Gradient
  Nx.iota({1,64,1}) |> Nx.divide(64) |> Nx.broadcast({1, 64,64,1}),
], axis: 3))
|> KinoZoetrope.TensorStack.new(
  titel: "Colorful gradient mixed from 3 channels"
)
```

```elixir
defmodule UsingOperators do 
  import Nx.Defn

  # Operatoren können in `defn` benutzt werden
  defn some_calculation(tensor) do
    600 - Nx.abs(tensor - 7 * 7 / 2) ** 2
  end
end

Nx.iota({7,7, 1})
|> UsingOperators.some_calculation()
|> KinoZoetrope.TensorStack.new(
  titel: "Some quadradic gradient",
  cmap: "copper"
)
```

```elixir
rad = 32
diam = 2*rad

dx = Nx.iota({1,diam,1})
  |> Nx.broadcast({diam,diam,1})
  |> Nx.subtract(rad)
dx2 = dx|> Nx.pow(2)

dy = Nx.iota({diam,1,1})
  |> Nx.broadcast({diam,diam,1})
  |> Nx.subtract(rad)
dy2 = dy |> Nx.pow(2)

circle_radius = Nx.add(dx2, dy2) |> Nx.sqrt() 
  |> Nx.reshape({1, diam,diam, 1})


circle_angle = Nx.atan2(dy, dx)
circle2_angle = Nx.atan2(dy2, dx2)

[dx2, dy2, circle_radius, circle_angle, circle2_angle]
|> KinoZoetrope.TensorStack.new(
  titel: "Circular masked generated via thresholding",
  labels: ["Distance y²", "Distance y²", "Radius","Angle", "Angle Squared"],
  cmaps: [nil,nil,nil,"hsv","rainbow"]
)
```

```elixir
mask = circle_radius
  # threshold radius
  |> Nx.less_equal(23)
  |> Nx.reshape({1, 64,64, 1})

[
  # Circle
  circle_radius,
  # Inner Mask
  mask,
  # Outer Mask
  mask |> Nx.logical_not(),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Circular masked generated via thresholding",
  labels: [
    "Circle", "Inner", "Outer",
  ]
)
```

```elixir
mask = circle_radius
  |> Nx.less_equal(23)
  |> Nx.reshape({1, 64,64, 1})

[
  # Rings
  circle_radius |> Nx.multiply(0.5) |> Nx.sin,
  # Squashed Rings
  circle_radius |> Nx.pow(0.3) |> Nx.multiply(10) |> Nx.sin(),

  # Animated Rings
  5..60//3 
  |> Enum.map(&Nx.sin(Nx.multiply(Nx.pow(circle_radius, 2/&1), 2*&1))) 
  |> Nx.concatenate(axis: 0),

  # Sinc = (sin(x)/x)
  circle_radius|> Nx.sin() |> Nx.divide(circle_radius) |> then(&Nx.select(Nx.is_nan(&1), 1, &1)),

  # Spiral 
  1..40//2 
  |> Enum.map(fn a ->
    circle_radius 
    |> Nx.pow(0.3) 
    |> Nx.multiply(10) 
    |> Nx.add(circle_angle) 
    |> Nx.subtract(a/3) 
    |> Nx.sin()
  end) |> Nx.concatenate(axis: 0),

  # 2D Fourier Transform of Spiral Swirl
  circle_radius |> Nx.pow(0.3) |> Nx.multiply(10) |> Nx.add(circle_angle) |> Nx.sin()
  |> Nx.reshape({1, 1, 64,64}) |> Nx.fft2() |> Nx.reshape({1, 64,64, 1}) 
  |> Nx.abs() |> Nx.log(),

  # Swirl
  1..20
  |> Enum.map(fn a ->
    circle_radius
    |> Nx.pow(0.25) 
    |> Nx.multiply(a * 0.8)
    |> Nx.add(circle_angle)  
    |> Nx.subtract((:math.pi - 0.1) * a)
    |> Nx.sin()
  end) |> Nx.concatenate(axis: 0),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Colorful Funny stuff",
  labels: [
    "Rings","Squashed Rings", "Animated Rings", 
    "Sinc", "Spiral", "Spiral Fourier Transform", "Swirl"
  ],
  cmaps: [
    nil,"viridis","rainbow", 
    "jet","managua","CMRmap", "plasma"
  ]
)
```

```elixir
Enum.zip(
  1..140 |> Enum.map(&:math.sin(&1/3)*20), 
  20..140 |> Enum.map(&:math.sin(&1/7)*17)
)
|> Enum.map(
  fn {x,y} -> 
    Nx.add(
      Nx.iota({1,diam,1})
        |> Nx.broadcast({diam,diam,1})
        |> Nx.subtract(rad + x)
        |> Nx.pow(2), 
        
      Nx.iota({diam,1,1})
        |> Nx.broadcast({diam,diam,1})
        |> Nx.subtract(rad + y)
        |> Nx.pow(2)
    )
    |> Nx.sqrt()
    |> Nx.reshape({1, diam,diam, 1})
  end
)
|> Nx.concatenate(axis: 0)
|> Nx.less(10)
|> KinoZoetrope.TensorStack.new(
  titel: "Animated Circular Mask",
  cmap: "viridis"
)
```

```elixir
1..3
|> Enum.map(fn c ->
  Enum.zip(
    1..90 |> Enum.map(&:math.sin(&1/17.0+c)*20), 
    1..90 |> Enum.map(&:math.cos(c*&1/13.0+c)*17)
  )
  |> Enum.map(fn 
    {x,y} -> Nx.add(
      Nx.iota({1,diam,1})
        |> Nx.broadcast({diam, diam, 1})
        |> Nx.subtract(rad - x)
        |> Nx.pow(2), 
    
      Nx.iota({diam, 1,1})
        |> Nx.broadcast({diam, diam, 1})
        |> Nx.subtract(rad - y)
        |> Nx.pow(2)
    )
    |> Nx.reshape({1, diam,diam, 1})
  end)
  |> Nx.concatenate(axis: 0)  
  |> Nx.sqrt()
end)
|> Nx.concatenate(axis: 3) 
|> then(&Nx.subtract(1, &1))
|> then(&Nx.subtract(&1, Nx.reduce_min(&1)))
|> then(&Nx.divide(&1, Nx.reduce_max(&1)))
|> Nx.multiply(255)
|> KinoZoetrope.TensorStack.new(
  titel: "Animated Color channels"
)
```

```elixir
[
  colormix, Nx.multiply(mask, colormix)
]
|> KinoZoetrope.TensorStack.new(
  titel: "Gradient cut with circular mask",
  labels: ["Color mix", "Masked Color Mix"]
)
```

```elixir
size = 64

gaussian = Nx.add(
  Nx.broadcast(0, {size,size,1})
    |> Nx.add(Nx.iota({1,size,1}))
    |> Nx.reshape({1, size,size})
    |> Nx.subtract(size / 2 - 0.5)
    |> Nx.pow(2), 
  Nx.broadcast(0, {size,size,1})
    |> Nx.add(Nx.iota({size,1,1}))
    |> Nx.reshape({1, size,size})
    |> Nx.subtract(size/2 - 0.5)
    |> Nx.pow(2)
)
|> Nx.divide(Nx.pow(size/4, 2))
|> Nx.negate()
|> Nx.exp()

gaussian
|> KinoZoetrope.TensorStack.new(
  titel: "Gaußian Mask / Filter of size #{size}x#{size}"
)
```

```elixir
rgba_color_mask = Nx.stack([
    gaussian,
    gaussian,
    gaussian,
    Nx.broadcast(1.0, Nx.shape(gaussian))
 ],axis: 3) 

rgba_blue_mask = Nx.stack([
    Nx.broadcast(1.0, Nx.shape(gaussian)),
    Nx.broadcast(1.0, Nx.shape(gaussian)),
    gaussian,
    Nx.broadcast(1.0, Nx.shape(gaussian))
],axis: 3) 

rgba_alpha_mask = Nx.stack([
    Nx.broadcast(1.0, Nx.shape(gaussian)),
    Nx.broadcast(1.0, Nx.shape(gaussian)),
    Nx.broadcast(1.0, Nx.shape(gaussian)),
    gaussian,
 ],axis: 3) 

[
  rgba_color_mask
  |> Nx.pow(0.4)
  |> Nx.multiply(colormix)
  |> Nx.multiply(1.5)
  |> Nx.min(255),

  rgba_blue_mask
  |> Nx.multiply(colormix)
  |> Nx.min(255),
  
  rgba_alpha_mask
  |> Nx.pow(0.4)
  |> Nx.multiply(colormix)
  |> Nx.multiply(1.5)
  |> Nx.min(255),
]
|> KinoZoetrope.TensorStack.new(
  titel: "Color gradient multiplied with gaussien mask",
  labels: ["Color channels multiplied", "Only blue channel masked out", "Alpha Channel Masked out"]
)
```

```elixir
{:ok, img} = Image.open(Kino.FS.file_path("perlgirl.png"))
{:ok, bin} = Vix.Vips.Image.write_to_binary(img)

girl_col = bin 
  |> Nx.from_binary(:u8) 
  |> Nx.reshape({1, 64, 64, 4}) 

girl_bw = girl_col
  |> Nx.reshape({64, 64, 4}) 
  # Discard alpha channel
  |> Nx.slice_along_axis(0, 3, axis: 2)
  # average color channels
  |> Nx.mean(axes: [2])
  |> Nx.as_type(:u8)
  |> Nx.reshape({64, 64, 1})

[
  girl_col, 
  girl_col |> Nx.transpose(axes: [3,1,2,0]), 
  girl_bw
] 
|> KinoZoetrope.TensorStack.new(
  titel: "Image read from the file system",
  labels: ["RGBA Image", "Single Channel (Slider)", "Grayscale (mean)"]
)
```

```elixir
{:ok, img} = Image.open(Kino.FS.file_path("hex.png"))
{:ok, bin} = Vix.Vips.Image.write_to_binary(img)

hex_col = bin 
  |> Nx.from_binary(:u8) 
  |> Nx.reshape({1, :auto, 98, 4}) 

hex_alpha = hex_col |> Nx.reshape({1, :auto, 98, 4}) |> Nx.slice_along_axis(3, 1, axis: 3)

hex_bw = hex_col
  |> Nx.reshape({:auto, 98, 4}) 
  # Discard alpha channel
  |> Nx.take(Nx.tensor([0,1,2]), axis: 2)
  # or |> Nx.slice_along_axis(0, 3, axis: 2)
  # average color channels
  |> Nx.mean(axes: [2])
  |> Nx.as_type(:u8)
  |> Nx.reshape({1, :auto, 98, 1})

# stich alpha channel back to r==g==b channels
hex_bw_alpha = [hex_bw, hex_bw, hex_bw, hex_alpha] 
  |> Nx.concatenate(axis: 3) 

[
  hex_col, 
  hex_col |> Nx.take(Nx.tensor([1,2,0,3]), axis: 3),
  hex_col |> Nx.transpose(axes: [3,1,2,0]), 
  hex_alpha,
  hex_bw,
  hex_bw_alpha
] 
|> KinoZoetrope.TensorStack.new(
  titel: "Elixir Hex Logo",
  labels: [
    "RGBA Image", 
    "Swapped Channels",
    "Single Color Channel (Slider)", 
    "Alpha", 
    "Grayscale (mean)", 
    "Grayscale with Alpha"
  ]
)
```

```elixir
make_gauss = fn size -> 
  Nx.add( Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({1,size,1})) 
    |> Nx.reshape({1, size,size, 1}) 
    |> Nx.subtract(size / 2 - 0.5) 
    |> Nx.pow(2), Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({size,1,1})) 
    |> Nx.reshape({1, size,size, 1})
    |> Nx.subtract(size/2 - 0.5) 
    |> Nx.pow(2) ) 
    |> Nx.divide(Nx.pow(size/4, 2)) 
    |> Nx.as_type(:f32)
    |> Nx.negate() 
    |> Nx.exp() 
    |> then(&Nx.divide(&1, Nx.sum(&1)))
    |> Nx.reshape({1,1,size,size})
    |> Nx.broadcast({4, 1,size,size})
end

11
|> then(&[
  # Original RGBA
  girl_col,

  # Blurred Result
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(&1), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [0,2,3,1]),

  # single channel
  girl_col |> Nx.transpose(axes: [3,1,2,0]),

  # Filter
  make_gauss.(&1) |> Nx.transpose(axes: [0,2,3,1]),

  # Single channel result
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(&1), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])
])
|> KinoZoetrope.TensorStack.new(
  titel: "Blurred Color Image",
  labels: [
    "Original RGBA", 
    "Result RGBA", 
    "Single Channel (slider)", 
    "Gaußian Filter", 
    "Result Single Channel (slider)"
  ]
)
```

```elixir
make_sobel = fn orientation -> 
  Nx.tensor([
    [-1,-2,-1],
    [ 0, 0, 0],
    [+1,+2,+1]
  ])
  |> Nx.transpose(axes: case orientation do 
      :vertical -> [1,0]
      :horizontal -> [0,1]
    end)
  |> Nx.reshape({1,1,3,3})
  |> then(&Nx.concatenate([&1,&1,&1,Nx.broadcast(1/9.0, {1,1,3,3})], axis: 0))
end


for orient <- [:vertical, :horizontal] do 
[
  girl_col |> Nx.transpose(axes: [3,1,2,0]),
  
  make_sobel.(orient) |> Nx.transpose(axes: [0,2,3,1]),

  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(orient), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])
]
end
|> List.flatten()
|> KinoZoetrope.TensorStack.new(
  titel: "Edge Detection via Sobel Filter",
  labels: [
    "Single Channel (slider)", "horizontal filter", "horizontal result", 
    "Single Channel (slider)", "vertical filter", "vertical result", 
  ],
  cmap: "viridis"
)
```

```elixir
make_gauss = fn size -> 
  Nx.add( 
    Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({1,size,1})) 
    |> Nx.reshape({1, size,size, 1}) 
    |> Nx.subtract(size / 2 - 0.5) 
    |> Nx.pow(2), Nx.broadcast(0, {size,size,1}) 
    |> Nx.add(Nx.iota({size,1,1})) 
    |> Nx.reshape({1, size,size, 1})
    |> Nx.subtract(size/2 - 0.5) 
    |> Nx.pow(2)
  ) 
  |> Nx.divide(Nx.pow(size/4, 2)) 
  |> Nx.as_type(:f32)
  |> Nx.negate() 
  |> Nx.exp() 
  |> then(&Nx.divide(&1, Nx.sum(&1)))
  |> Nx.reshape({1,1,size,size})
  |> Nx.broadcast({4, 1,size,size})
end

make_sobel = fn orientation -> 
  Nx.tensor([
    [-1,-2,-1],
    [ 0, 0, 0],
    [+1,+2,+1]
  ])
  |> Nx.transpose(axes: case orientation do 
      :vertical -> [1,0]
      :horizontal -> [0,1]
    end)
  |> Nx.reshape({1,1,3,3})
  |> then(&Nx.concatenate([&1,&1,&1,Nx.broadcast(1/9.0, {1,1,3,3})], axis: 0))
end

hypot = fn a, b ->
  Nx.sqrt(Nx.add(Nx.pow(a,2), Nx.pow(b,2)))
end

soft_girl_col = 
  girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.conv(make_gauss.(3), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [0,2,3,1])


verts = soft_girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(:vertical), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])

horts = soft_girl_col
  |> Nx.transpose(axes: [0,3,1,2])
  |> Nx.divide(255)
  |> Nx.conv(make_sobel.(:horizontal), padding: :same, feature_group_size: 4)
  |> Nx.transpose(axes: [1,2,3,0])

orient = Nx.atan2(verts, horts)

[
  soft_girl_col |> Nx.transpose(axes: [3,1,2,0]),
  verts,
  horts,
  orient,
  orient,
  hypot.(verts, horts) 
  |> Nx.greater_equal(0.5)
  |> Nx.multiply(orient)
]
|> KinoZoetrope.TensorStack.new(
  titel: "Edge Orientation",
  labels: [
    "Single Channel (slider)", "Vertical Result", "Horizontal Result", 
    "Edge Orientation", "Edge Orientation", "masked orientation", 
  ],
  cmaps: [nil, "viridis", "viridis", "gray", "hsv", "hsv"]
)
```

## Game of Life

```elixir
world = Nx.tensor([
  [0,0,1,0,0,0,0,0,0,0,0],
  [1,0,1,0,0,0,0,0,0,0,0],
  [0,1,1,0,0,0,0,1,0,0,0],
  [0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0],
  [0,0,1,0,0,0,0,0,0,0,0],
  [0,0,0,1,0,0,0,0,0,0,0],
  [0,1,1,1,0,0,0,1,0,1,0],
  [0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,1,0,0],
])
|> Nx.reshape({1,11,11,1})

gol_filter = Nx.tensor([
  [1.0,1.0,1.0],
  [1.0,0.5,1.0],
  [1.0,1.0,1.0]
])
|> Nx.reshape({1,3,3,1})
  
[
  Nx.subtract(1, world),
  gol_filter,
] |> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  vmin: 0,
  vmax: 1,
  labels: ["World (inverted)", "Filter Kernel"]
)
```

```elixir
world = Nx.tensor([
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,1,0,0,0,0,0,0,0,0],
  [0,0,1,1,0,0,0,0,1,0,0,0],
  [0,0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,1,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,1,0,0,0,0,0,0,0],
  [0,0,1,1,1,0,0,0,1,0,1,0],
  [0,0,0,0,0,0,0,0,0,1,1,0],
  [0,0,0,0,0,0,0,0,0,1,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
])
|> Nx.reshape({1,12,12,1})
|> Nx.transpose(axes: [0,3,1,2])


gol_filter = Nx.tensor([
  [1.0,1.0,1.0],
  [1.0,0.3,1.0],
  [1.0,1.0,1.0],
])
|> Nx.reshape({1,1,3,3})

circular_pad_2d = fn tensor, pad_h, pad_w ->
  {_n, _c, h, w} = Nx.shape(tensor)
  h_idx =
    Nx.remainder(
      Nx.add(h, Nx.subtract(Nx.iota({h + 2 * pad_h}), pad_h)),
      h
    )
  w_idx =
    Nx.remainder(
      Nx.add(w, Nx.subtract(Nx.iota({w + 2 * pad_w}), pad_w)),
      w
    )
  
  tensor
  |> Nx.take(h_idx, axis: 2)
  |> Nx.take(w_idx, axis: 3)
end

do_step = fn state -> 
  circular_pad_2d.(state, 1,1)
  |> Nx.conv(gol_filter)
  |> Nx.subtract(3)
  |> Nx.abs()
  |> Nx.less(1)
end

[
  Stream.iterate(world, do_step)
    |> Enum.take(40)
    |> Enum.drop(1)
    |> Enum.map(&Nx.transpose(Nx.subtract(1, &1), axes: [0,2,3,1]))
    |> Nx.concatenate(),
  
  Stream.iterate(world, do_step)
    |> Enum.take(40)
    |> Enum.map(&Nx.transpose(Nx.subtract(1, &1), axes: [0,2,3,1]))
    |> Nx.concatenate(),
    
  gol_filter|> Nx.reshape({1,3,3,1})
]
|> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  labels: ["World (Prev)" , "World (next)", "Filter Kernel"],
  vmin: 0,
  vmax: 1
)
```

```elixir
world = Nx.tensor([[
  [0,0,0,1,0,0,0,0,0,0,0,0],
  [0,1,0,1,0,0,0,0,0,0,0,0],
  [0,0,1,1,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
  [0,0,0,0,0,0,0,0,0,0,0,0],
]])

gol_filter_spectrum = Nx.fft2(Nx.tensor([
  [0.5,1,0,0,0,0,0,0,0,0,0,1.0],
  [1.0,1,0,0,0,0,0,0,0,0,0,1.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [0.0,0,0,0,0,0,0,0,0,0,0,0.0],
  [1.0,1.0,0,0,0,0,0,0,0,0,0,1.0],
]))


do_step = fn state -> 
  Nx.ifft2(Nx.multiply(Nx.fft2(state), gol_filter_spectrum))
  |> Nx.subtract(3)
  |> Nx.abs()
  |> Nx.less(1)
end

Stream.iterate(world, do_step)
|> Enum.take(100)
|> Enum.map(&Nx.reshape(Nx.subtract(1, &1), {1,12,12,1}))
|> Nx.concatenate()
|> KinoZoetrope.TensorStack.new(
  titel: "Game of Life",
  labels: ["World (Inverted)"]
)
```
